---
description: cc-insight開発における絶対遵守ルール - 全ての開発作業でAIが従うべき必須ルール
---

# 🔒 CC Insight 開発ルールブック（AI絶対遵守）

**このドキュメントは、AIがcc-insightプロジェクトで開発作業を行う際に絶対に遵守すべきルールを定義する。**

**最終更新**: 2026-01-12  
**適用範囲**: cc-insightプロジェクト内の全ての開発作業

---

## 第1章: 基本原則

### 1.1 オーナー承認の原則

**全ての重要な操作はオーナー（菅原さん）の承認を得てから実行する。**

以下の操作は承認なしに実行してはならない：
- mainブランチへのマージ
- ファイルの削除
- データベースへの書き込み操作
- 本番環境への影響がある変更
- 新規ライブラリの追加

### 1.2 安全第一の原則

**「速さ」より「安全」を優先する。**

- 不確実な場合は確認する
- リスクがある場合は報告する
- 問題が起きても元に戻せる状態を維持する

### 1.3 透明性の原則

**全ての作業内容をオーナーに明確に伝える。**

- 何をしようとしているか事前に説明する
- 何をしたか完了後に報告する
- 問題が発生したら即座に報告する

---

## 第2章: 禁止事項（絶対にやってはならない）

### 🔴 2.1 mainブランチでの直接作業

```
禁止: git checkout main で作業すること
必須: feature/〇〇 ブランチを作成してから作業
```

**違反時の影響**: 本番環境が即座に壊れる可能性

### 🔴 2.2 無許可でのマージ

```
禁止: オーナーの許可なくmainにマージすること
必須: 「マージしてよいですか？」と確認し、明示的な許可を得る
```

**オーナーからの「OK」「許可する」「進めて」等の明示的な承認が必要**

### 🔴 2.3 本番データベースへの直接操作

```
禁止: Firestoreの本番データを直接変更・削除すること
許可: 読み取りのみ（調査目的）
```

データの変更が必要な場合は、管理画面経由またはオーナーに操作を依頼する。

### 🔴 2.4 秘密情報の出力

```
禁止: APIキー、パスワード、トークンをチャットに出力すること
必須: 「.envファイルを確認してください」と伝える
```

### 🔴 2.5 確認なしのファイル削除

```
禁止: 使用状況を調査せずにファイルを削除すること
必須: grep検索で参照箇所を確認し、オーナーに削除候補を提示して承認を得る
```

### 🔴 2.6 例外の許容

```
禁止: 「このファイルだけは例外で」という妥協を許可すること
必須: Zero Exception Policy - 全ファイルを同一基準で処理する
```

---

## 第3章: 必須フロー

### 3.1 開発開始時のフロー

**フロー概要図:**
```
┌─────────────────┐
│ 0. 要件理解      │  ← オーナーからの指示を受ける
└────────┬────────┘
         ↓
┌─────────────────┐
│ 1. ブランチ作成   │  ← 安全な作業環境を確保
└────────┬────────┘
         ↓
┌─────────────────┐
│ 2. 調査          │  ← 既存コードを理解する
└────────┬────────┘
         ↓
┌─────────────────┐
│ 3. 計画作成      │  ← 調査結果を踏まえて計画
└────────┬────────┘
         ↓
┌─────────────────┐
│ 4. オーナー承認   │  ← 承認されるまで実装しない
└────────┬────────┘
         ↓
┌─────────────────┐
│ 5. 段階的実装    │  ← 3ファイル以内ずつ
└─────────────────┘
```

**なぜ「調査」が「計画」より先か？**

既存プロジェクトで機能を追加する場合、調査せずに計画を立てると：
- ❌ 「この機能はすでにあります」と後から判明する
- ❌ 「既存コードと競合します」と後から判明する
- ❌ 無駄な作業が発生する

調査してから計画を立てることで：
- ✅ 既存コードの構造を把握した上で計画できる
- ✅ 再利用できる既存関数を活用できる
- ✅ 現実的で正確な計画が立てられる

**各ステップの詳細:**

```
0. 要件理解
   → オーナーからの指示内容を正確に把握する
   → 不明点があれば確認する

1. 新しいブランチを作成する
   → git checkout -b feature/機能名
   → mainブランチでは絶対に作業しない

2. 関連ファイルを調査する
   → 既存コードの構造を把握
   → 使用できる既存関数を特定
   → 影響を受ける可能性のあるファイルを洗い出す

3. 実装計画書を作成する
   → 変更ファイル一覧、変更内容、影響範囲を明記
   → 調査結果に基づいた具体的な計画

4. オーナーに計画書を提示し承認を得る
   → 承認されるまで実装を開始しない
   → 計画に問題があれば修正して再提示

5. 承認後、段階的に実装する
   → 3ファイル以内ずつ変更
   → 各段階でビルド確認
```

### 3.2 実装中のフロー

```
1. 各変更後にビルド確認
   → npm run build でエラーがないことを確認

2. エラーが発生したら即座に修正
   → 放置して次に進まない

3. 進捗を定期的に報告
   → 大きな変更時は中間報告
```

### 3.3 完了時のフロー

```
1. 最終ビルド確認
   → npm run build が成功すること

2. 変更サマリーを作成
   → 何を変更したか、どのファイルに影響があるか

3. プレビュー環境のURLを提示
   → オーナーが動作確認できるように

4. マージ許可を明示的に求める
   → 「マージしてよいですか？」

5. 許可後のみマージを実行
   → 許可がなければマージしない

6. マージ後、本番デプロイ開始を報告
```

---

## 第4章: アーキテクチャ遵守

### 4.1 レイヤー構造

CC Insightは以下のレイヤー構造に従う：

```
┌─────────────────────────────┐
│  UI Layer (app/, components/) │  ← Firebase直接アクセス禁止
├─────────────────────────────┤
│  Service Layer (lib/services/) │  ← Firebase操作はここで
├─────────────────────────────┤
│  Type Layer (lib/types/)       │  ← 型定義
├─────────────────────────────┤
│  Core (lib/firebase.ts)        │  ← Firebase初期化のみ
└─────────────────────────────┘
```

### 4.2 import規則

**UI Layer (`app/`, `components/`) では以下を遵守:**

```typescript
// ✅ 許可
import { createReport } from "@/lib/services/report";
import { Report, User } from "@/lib/types";
import { Timestamp } from "@/lib/types"; // lib/typesから

// ❌ 禁止
import { collection, getDocs } from "firebase/firestore";
import { db } from "@/lib/firebase";
```

### 4.3 新規ファイル作成時

- UIコンポーネント → `app/` または `components/`
- データ操作関数 → `lib/services/`
- 型定義 → `lib/types/`
- ユーティリティ → `lib/`

---

## 第5章: コード品質

### 5.1 TypeScript

```
必須: 全ファイルでTypeScriptを使用
禁止: any型の多用（必要最小限に）
必須: 型定義は lib/types/ で管理
```

### 5.2 命名規則

```
ファイル名: kebab-case (例: user-profile.tsx)
関数名: camelCase (例: getUserById)
型名: PascalCase (例: UserProfile)
定数: UPPER_SNAKE_CASE (例: MAX_RETRY_COUNT)
```

### 5.3 コメント

```
必須: 複雑なロジックにはコメントを追加
必須: 関数には目的を説明するJSDocコメント
言語: 日本語で記述
```

---

## 第6章: Git運用

### 6.1 ブランチ命名

```
feature/機能名     - 新機能開発
fix/バグ名         - バグ修正
refactor/対象     - リファクタリング
docs/対象         - ドキュメント更新
chore/対象        - その他の作業
```

### 6.2 コミットメッセージ

```
feat: 新機能の説明
fix: バグ修正の説明
refactor: リファクタリングの説明
docs: ドキュメント更新の説明
chore: その他の作業の説明
```

**禁止**: 「修正」「更新」「変更」などの曖昧なメッセージ

### 6.3 ブランチ管理

```
必須: 作業完了後もブランチを維持（削除はオーナー指示時のみ）
必須: mainへのマージはオーナー承認後のみ
```

---

## 第7章: テスト・検証

### 7.1 ビルド確認

```
必須: 全ての変更後に npm run build を実行
必須: エラーがないことを確認してから次に進む
必須: 警告も可能な限り解消する
```

### 7.2 動作確認

```
必須: プレビュー環境での動作確認をオーナーに依頼
必須: 主要機能（ログイン、DM、管理画面）が動作することを確認
必須: コンソールにエラーがないことを確認
```

### 7.3 回帰テスト

```
必須: 既存機能が壊れていないことを確認
必須: 変更に関連する画面を全てチェック
```

---

## 第8章: ドキュメント管理

### 8.1 更新対象

コード変更時は以下のドキュメントも更新する：

```
docs/01_ARCHITECTURE.md  - アーキテクチャ変更時
docs/02_SCHEMA.md        - データ構造変更時
docs/03_DATA_FLOW.md     - データフロー変更時
```

### 8.2 作成ルール

```
必須: Markdown形式で記述
必須: 目次を含める（長いドキュメントの場合）
必須: 具体例を含める
```

---

## 第9章: 緊急時対応

### 9.1 ビルドエラー発生時

```
1. エラーメッセージを確認
2. 原因を特定
3. 修正を実施
4. 再度ビルド確認
5. 修正内容をオーナーに報告
```

### 9.2 本番障害発生時

```
1. 即座にオーナーに報告
2. 直前の変更を確認
3. 必要に応じてrevertを提案
4. オーナーの指示に従う
```

### 9.3 判断に迷う場合

```
1. 作業を一時停止
2. 状況をオーナーに報告
3. オーナーの指示を待つ
4. 勝手に判断して進めない
```

---

## 第10章: コミュニケーション

### 10.1 報告のタイミング

```
必須: 作業開始時 - 何をするか説明
必須: 計画完了時 - 承認を求める
必須: 実装完了時 - 結果を報告
必須: 問題発生時 - 即座に報告
```

### 10.2 報告のフォーマット

```
【作業開始報告】
- 作業内容: 〇〇
- 対象ファイル: 〇〇
- 予想所要時間: 〇〇

【完了報告】
- 変更ファイル: 〇〇
- 変更内容: 〇〇
- ビルド結果: 成功/失敗
- 動作確認: プレビューURL
```

### 10.3 質問・確認

```
必須: 曖昧な指示は確認する
必須: 複数の解釈ができる場合は確認する
禁止: 推測で進める
```

---

## 第11章: パフォーマンス・最適化

### 11.1 ページ読み込み

```
考慮: 不要なimportを避ける
考慮: 大きなライブラリは動的importを検討
考慮: 画像は最適化して使用
```

### 11.2 データベースアクセス

```
考慮: 不要なクエリを避ける
考慮: インデックスを活用
考慮: キャッシュを適切に使用
```

---

## 第12章: セキュリティ

### 12.1 認証・認可

```
必須: 認証が必要なページは適切に保護
必須: 管理者機能は権限チェックを実装
禁止: クライアントサイドのみでの権限チェック
```

### 12.2 データ検証

```
必須: ユーザー入力は検証する
必須: Firestore Rulesを適切に設定
禁止: 信頼できないデータを直接使用
```

### 12.3 環境変数

```
必須: 秘密情報は.envファイルで管理
必須: .envはgitignoreに含める
禁止: 秘密情報をコードにハードコード
```

---

## 第13章: 依存関係管理

### 13.1 新規パッケージ追加

```
必須: オーナーに追加理由を説明し承認を得る
必須: セキュリティリスクを確認
考慮: メンテナンス状況を確認
```

### 13.2 既存パッケージ更新

```
必須: 破壊的変更を確認
必須: ビルド・テストで問題ないことを確認
必須: オーナーに報告
```

---

## 第14章: デッドコード管理

### 14.1 定期チェック

```
推奨: 定期的に未使用コードを調査
推奨: 参照されていないファイルを報告
必須: 削除前にオーナー承認を得る
```

### 14.2 削除手順

```
1. grep検索で参照箇所を確認
2. 動的インポートの可能性を確認
3. 設定ファイルでの参照を確認
4. オーナーに削除候補を提示
5. 承認後のみ削除を実行
```

---

## 第15章: チェックリスト

### 15.1 作業開始前チェックリスト

- [ ] featureブランチを作成したか
- [ ] 関連ファイルを調査したか
- [ ] 実装計画を作成したか
- [ ] オーナーの承認を得たか

### 15.2 作業完了時チェックリスト

- [ ] ビルドが成功するか
- [ ] 型エラーがないか
- [ ] コンソールにエラーがないか
- [ ] 既存機能が動作するか
- [ ] ドキュメントを更新したか
- [ ] コミットメッセージは明確か
- [ ] マージ許可を得たか

---

## 付録A: よくある誤り

| 誤り | 正しい対応 |
|------|-----------|
| mainで直接作業 | featureブランチを作成 |
| 許可なくマージ | 明示的な許可を得る |
| ビルド未確認でプッシュ | 毎回ビルド確認 |
| 例外を許可 | Zero Exception Policy |
| 曖昧なコミット | 具体的なメッセージ |
| ドキュメント未更新 | コードと同時に更新 |

---

## 付録B: 緊急連絡フレーズ

問題発生時は以下のフレーズで即座に報告する：

```
🔴 【緊急】本番環境に影響がある問題が発生しました
🟠 【警告】ビルドエラーが発生しました
🟡 【確認】判断に迷う点があります。確認させてください
```

---

**このルールブックは絶対遵守とする。**

**例外は認めない。迷ったら確認する。**
